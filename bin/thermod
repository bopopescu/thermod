#!/usr/bin/python3
# -*- coding: utf-8 -*-
"""Thermod daemon.

Copyright (C) 2017 Simone Rossetto <simros85@gmail.com>

This file is part of Thermod.

Thermod is free software: you can redistribute it and/or modify
it under the terms of the GNU General Public License as published by
the Free Software Foundation, either version 3 of the License, or
(at your option) any later version.

Thermod is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
GNU General Public License for more details.

You should have received a copy of the GNU General Public License
along with Thermod.  If not, see <http://www.gnu.org/licenses/>.
"""

import os
import sys
import logging
import argparse
import signal
import tempfile
import lockfile
import threading
import asyncio
import time

from daemon import DaemonContext, pidfile
from logging.handlers import SysLogHandler, SMTPHandler
from jsonschema import ValidationError

from thermod import common, config
from thermod.common import ScriptError, LogStyleAdapter, ThermodStatus
from thermod.thermometer import ScriptThermometer, ThermometerError, PiAnalogZeroThermometer, MCP3008
from thermod.heating import ScriptHeating, HeatingError, PiPinsRelayHeating
from thermod.timetable import TimeTable, JsonValueError
from thermod.socket import ControlSocket
from thermod.version import __version__ as PROGRAM_VERSION

__date__ = '2015-09-08'
__updated__ = '2017-10-19'

# TODO documentare return code
# TODO rivedere documentazione e provare a generarla con con doxygen (doxypy oppure doxypypy)
# TODO creare manpage per questo file
# TODO capire come fare ad eseguire i test alla creazione del pacchetto deb

script_path = os.path.dirname(os.path.realpath(__file__))
main_return_code = common.RET_CODE_OK

# parsing input arguments
parser = argparse.ArgumentParser(description='Thermod: programmable thermostat daemon for smart-heating automation')
parser.add_argument('-v', '--version', action='version', version='%(prog)s {}'.format(PROGRAM_VERSION))
parser.add_argument('-C', '--config', action='store', default=None, help='read configuration from CONFIG file (full path)')
parser.add_argument('-D', '--debug', action='store_true', help='start the daemon in debug mode')
parser.add_argument('-F', '--foreground', action='store_true', help='start the daemon in foreground')
parser.add_argument('-L', '--log', action='store', default=None, help='write log messages to LOG file (full path)')
parser.add_argument('-P', '--pid', action='store', default='/run/thermod.pid', help='where to create PID file if required (full path)')
parser.add_argument('--systemd', action='store_true', help='use only if started by systemd')
args = parser.parse_args()

# setting up logging system
logger = LogStyleAdapter(logging.getLogger(common.LOGGER_BASE_NAME))
logger.setLevel(logging.INFO)

if args.debug:
    logger.setLevel(logging.DEBUG)

if args.foreground and not args.systemd:
    console = logging.StreamHandler(sys.stdout)
    console.setFormatter(logging.Formatter(fmt=common.LOGGER_FMT_MSG,
                                           datefmt=common.LOGGER_FMT_TIME,
                                           style=common.LOGGER_FMT_STYLE))
    logger.addHandler(console)
    logger.debug('executing in foreground, logging to console')
else:
    syslog = SysLogHandler(address='/dev/log', facility=SysLogHandler.LOG_DAEMON)
    syslog.setFormatter(logging.Formatter(fmt=common.LOGGER_FMT_MSG_SYSLOG,
                                          style=common.LOGGER_FMT_STYLE))
    logger.addHandler(syslog)
    logger.debug('executing in background, logging to syslog (daemon)')

if args.log:
    logfile = None
    
    try:
        logfile = logging.FileHandler(args.log, mode='a')
    
    except PermissionError as pe:
        logger.warning('cannot write log to `{}`: {}', args.log, pe)
        
        try:
            (_fd, _path) = tempfile.mkstemp(prefix='tmp_thermod', suffix='.log', test=True)
            _fd.close()
            
            logger.info('the log will be written to temp file `{}`', _path)
            logfile = logging.FileHandler(_path, mode='w')
        
        except Exception as e:
            logger.error('cannot write logfile: {}', e)
            logger.info('the daemon will start without logfile')
    
    if logfile:
        logfile.setFormatter(logging.Formatter(fmt=common.LOGGER_FMT_MSG,
                                               datefmt=common.LOGGER_FMT_DATETIME,
                                               style=common.LOGGER_FMT_STYLE))
        logger.addHandler(logfile)


# reading configuration files
(cfg, main_return_code) = config.read_config_file(args.config)

if main_return_code != common.RET_CODE_OK:
    logger.info('closing daemon with return code {}', main_return_code)
    exit(main_return_code)


# parsing main settings
settings = config.parse_main_settings(cfg)
debug = settings.debug or args.debug

if main_return_code != common.RET_CODE_OK:
    logger.info('closing daemon with return code {}', main_return_code)
    exit(main_return_code)


# if executed in foreground we ignore the 'enabled' setting in config file
enabled = settings.enabled or args.foreground

# if the daemon is disabled we exit immediately
if not enabled:
    logger.info('daemon disabled in configuration file, exiting...')
    exit(common.RET_CODE_DAEMON_DISABLED)


# if mail server is present in configuration file, a new SMTPHandler is created
if settings.email['server']:
    maillog = SMTPHandler(settings.email['server'],
                          settings.email['sender'],
                          settings.email['recipients'],
                          settings.email['subject'],
                          settings.email['credentials'])
    
    maillog.setFormatter(logging.Formatter(fmt=common.LOGGER_FMT_MSG_MAILLOG,
                                           datefmt=common.LOGGER_FMT_DATETIME,
                                           style=common.LOGGER_FMT_STYLE))
    
    maillog.setLevel(logging.WARNING)
    logger.addHandler(maillog)


# setting again the debug level if requested in configuration file
if debug:
    logger.setLevel(logging.DEBUG)


# initializing base objects
try:
    logger.debug('creating base objects')
    
    # the main lock
    lock = threading.Condition()
    
    # the timetable
    timetable = TimeTable(settings.tt_file)
    
    # the heating
    if settings.heating['manager'] == 'scripts':
        heating = ScriptHeating(settings.heating['on'],
                                settings.heating['off'],
                                settings.heating['status'],
                                debug)
    
    elif settings.heating['manager'] == 'PiPinsRelay':
        heating = PiPinsRelayHeating(settings.heating['pins'],
                                     settings.heating['level'])
    
    # An `elif` can be added with additional specific heating classes
    # once they will be created.
    else:
        # The execution should not arrive here because the settings are
        # already checked inside common.parse_main_settings() function.
        raise RuntimeError('invalid heating configuration')
    
    # the thermometer
    if settings.thermometer['script'][0] == '/':  # a full path starts with /
        thermometer = ScriptThermometer(settings.thermometer['script'],
                                        debug,
                                        settings.thermometer['scale'],
                                        settings.thermometer['t_ref'],
                                        settings.thermometer['t_raw'])
        
    elif settings.thermometer['script'] == 'PiAnalogZero':
        # The PiAnalogZeroThermometer uses Thread and gpiozero.MCP3008 objects
        # that have strange behaviours in case of python-daemon DaemonContext,
        # they must be created/started *inside* the DaemonContext, not outside.
        # So, in case of background launching with PiAnalogZeroThermometer, the
        # thermometer object is created inside DaemonContext (see at the end
        # of this file the same "if args.foreground or args.systemd").
        if args.foreground or args.systemd:
            thermometer = PiAnalogZeroThermometer(
                                settings.thermometer['channels'],
                                settings.thermometer['scale'],
                                settings.thermometer['t_ref'],
                                settings.thermometer['t_raw'])
        else:
            # here thermod is launched in background
            thermometer = None
    
    # An `elif` can be added with additional specific thermometer classes
    # once they will be created.
    else:
        # The execution should not arrive here because the settings are
        # already checked inside common.parse_main_settings() function.
        raise RuntimeError('invalid thermometer configuration')

except ScriptError as se:
    main_return_code = common.RET_CODE_SCRIPT_INIT_ERR
    logger.critical('error accessing the script `{}`: {}', se.script, se)

except FileNotFoundError as fnfe:
    main_return_code = common.RET_CODE_TT_NOT_FOUND
    logger.critical('cannot find timetable file `{}`', settings.tt_file)

except PermissionError as pe:
    main_return_code = common.RET_CODE_TT_READ_ERR
    logger.critical('cannot read timetable file `{}`', settings.tt_file)

except OSError as oe:
    main_return_code = common.RET_CODE_TT_OTHER_ERR
    logger.critical('error accessing timetable file `{}`: {}', settings.tt_file, oe)

except ValueError as ve:
    main_return_code = common.RET_CODE_TT_INVALID_SYNTAX
    logger.critical('timetable file is not in JSON format or has syntax errors: {}', ve)

except ValidationError as jsve:
    main_return_code = common.RET_CODE_TT_INVALID_CONTENT
    logger.critical('invalid element {} in timetable file: {}', list(jsve.path), jsve.message)

except HeatingError as he:
    main_return_code = common.RET_CODE_HW_INIT_ERR
    logger.critical('cannot initialize heating: {}', he)

except ThermometerError as te:
    main_return_code = common.RET_CODE_HW_INIT_ERR
    logger.critical('cannot initialize thermometer: {}', he)

except RuntimeError as re:
    main_return_code = common.RET_CODE_CFG_FILE_UNKNOWN_ERR
    logger.critical('error during creation of base objects: {}', re)

except Exception as e:
    main_return_code = common.RET_CODE_INIT_ERR
    logger.critical('error during daemon initialization: {}', e, exc_info=True)

except KeyboardInterrupt:
    main_return_code = common.RET_CODE_KEYB_INTERRUPT

else:
    main_return_code = common.RET_CODE_OK
    logger.debug('base objects created')
    
finally:
    if main_return_code != common.RET_CODE_OK:
        logger.info('closing daemon with return code {}', main_return_code)
        exit(main_return_code)


def shutdown(signum=None, frame=None, exitcode=common.RET_CODE_OK):
    global enabled, main_return_code
    
    logger.info('shutdown requested')
    with lock:
        enabled = False
        lock.notify_all()
    
    # setting the global return code
    main_return_code = exitcode


def reload_timetable(signum=None, frame=None):
    logger.info('timetable reload requested')
    with lock:
        try:
            timetable.reload()
            lock.notify_all()
        
        except OSError as oe:
            logger.warning('cannot reload timetable file `{}`, old settings '
                           'remain unchanged: {}', timetable.filepath, oe)
        
        except ValidationError as jsve:
            logger.warning('cannot reload settings, timetable file contains '
                           'invalid data in element {}: {}', list(jsve.path),
                           jsve.message)
        
        except ValueError as ve:
            logger.warning('cannot reload settings, timetable file contains '
                           'invalid data: {}', ve)
        
        except Exception as e:
            logger.warning('error while reloading timetable, old settings '
                           'remain unchanged: {}', e)


def thermostat_cycle(timetable, heating, thermometer, lock, loop):
    """The main cycle of temperature checking.
    
    Periodically checks the temperature and switch on/off the heating
    accordingly.
    
    If a known error is catched somewhere, a message is printed to syslog and
    the daemon is leaved running even if a manual operation of the user is
    required to fix the contidion. In case of unknown error, a critical message
    is printed and the daemon is closed.
    """
    
    global main_return_code
    logger.info('daemon started ({})', PROGRAM_VERSION)
    
    try:
        # starting control socket
        socket = ControlSocket(timetable, heating, thermometer,
                               settings.host, settings.port,
                               lock, loop)
        socket.start()
    
    # TODO controllare gli errori con il nuovo socket asyncrono
    except OSError as oe:
        # probably the socket address is already in use
        logger.critical('cannot start control socket: {}', oe)
        main_return_code = common.RET_CODE_SOCKET_PORT_ERR
    
    except Exception as e:
        logger.critical('cannot start control socket: {}', e, exc_info=True)
        main_return_code = common.RET_CODE_SOCKET_START_ERR

    except KeyboardInterrupt:
        main_return_code = common.RET_CODE_KEYB_INTERRUPT
    
    else:
        try:
            logger.info('the heating is currently {}', (heating.is_on() and 'ON' or 'OFF'))
            
        except Exception as e:
            # We report the error as a severe error but we do nothing because
            # it can be a transient error, if it isn't transient, the error
            # will appears again in the hereafter "while" cycle and it will
            # be managed there.
            logger.error('cannot query the heating to retrieve current status: {}', e)
            
        except KeyboardInterrupt:
            shutdown(exitcode=common.RET_CODE_KEYB_INTERRUPT)
        
        # The following variable is needed to print info messages only
        # when no timeout has occurred, that means that someone has changed
        # some settings.
        cycle_timeout = False
        
        # the real cycle of temperature checking
        while enabled:
            try:
                with lock:
                    try:
                        should_be_on = timetable.should_the_heating_be_on(
                                            thermometer.temperature,
                                            heating.status)
                        
                        _msg = ('status: {!r}, '
                                'current: {:.1f}, '
                                'target: {:.1f}').format(
                                    should_be_on.status.status,
                                    should_be_on.status.current_temperature,
                                    float(should_be_on.status.target_temperature or 'NaN'))
                        
                        if should_be_on == should_be_on.status.heating_status:
                            # The heating is already as it should be, so an
                            # info message is printed only if some settings
                            # have been changed from outside (the timeout has
                            # not occurred).
                            log = (logger.info if not cycle_timeout else logger.debug)
                            log('heating already {} ({})',
                                ('ON' if should_be_on.status.heating_status else 'OFF'),
                                _msg)
                        
                        else:  # the heating must be switched
                            if should_be_on:
                                heating.switch_on()
                            else:
                                heating.switch_off()
                            
                            logger.info('heating switched {} ({})',
                                        ('ON' if should_be_on else 'OFF'),
                                        _msg)
                    
                    except ValidationError as jsve:
                        # The internal settings must be valid otherwise an error
                        # should have already been catched in other sections of
                        # the program, even if new settings are set from
                        # socket connection. We print a critical message but
                        # we leave the daemon running. Manual intervention of
                        # the user is required to fix this condition.
                        newstatus = ThermodStatus(time.time(), error='Invalid element in timetable file')
                        logger.critical('invalid element {} in timetable file: {}', list(jsve.path), jsve)
                        #shutdown(exitcode=common.RET_CODE_RUN_INVALID_STATE)
                    
                    except JsonValueError as jve:
                        # A strange value has been set somewhere and the daemon
                        # didn't catch the appropriate exception. We print a
                        # critical message but we leave the daemon running.
                        # Manual intervention of the user is required to fix
                        # this condition.
                        newstatus = ThermodStatus(time.time(), error='Invalid value in running daemon')
                        logger.critical(jve)
                        #shutdown(exitcode=common.RET_CODE_RUN_INVALID_VALUE)
                    
                    except ScriptError as se:
                        # One of the external scripts reported an error, we
                        # print it as a severe error but we leave the daemon
                        # running even if probably it is not fully functional.
                        newstatus = ThermodStatus(time.time(), error='Error in script {}'.format(se.script))
                        logger.error('the script `{}` reported the following '
                                     'error: {}', se.script, se)
                    
                    except ThermometerError as te:
                        newstatus = ThermodStatus(time.time(), error='Error from thermometer')
                        logger.error('error from thermometer: {}', te)
                        logger.debug(te.suberror)
                    
                    except HeatingError as he:
                        newstatus = ThermodStatus(time.time(), error='Error from heating')
                        logger.error('error from heating: {}', he)
                        logger.debug(he.suberror)
                    
                    except Exception:
                        # There is an unknown error. We create an error-status
                        # for monitors and we re-raise the exception.
                        newstatus = ThermodStatus(time.time(), error='Unknown Error')
                        raise
                    
                    except KeyboardInterrupt:
                        newstatus = ThermodStatus(time.time(), error='Shutting down Thermod')
                        raise
                    
                    else:
                        newstatus = should_be_on.status._replace(heating_status=heating.status)
                    
                    finally:  # we update all connected monitors
                        socket.update_monitors(newstatus)
                    
                    # A shutdown may have been requested before reaching
                    # this point and in such situation we don't have to
                    # wait for a notify, simply go on and exit the cycle.
                    if enabled:
                        # We suspend the process and wait to recheck the temperature.
                        # The 'wait' method returns False on timeout, thus we
                        # negate it to have cycle_timeout equal True when a
                        # timeout has occurred.
                        cycle_timeout = not lock.wait(settings.interval)
            
            
            except Exception as e:
                # An unknown error occurred somewhere, a critical message is
                # printed and the daemon will be closed.
                logger.critical('unknown error occurred: {}', e, exc_info=True)
                shutdown(exitcode=common.RET_CODE_RUN_OTHER_ERR)
            
            except KeyboardInterrupt:
                shutdown(exitcode=common.RET_CODE_KEYB_INTERRUPT)
    
    finally:    
        logger.debug('stopping daemon')
        
        try:
            with lock:
                socket.stop()
                socket.join(10)
        
        except NameError:
            # The socket doesn't exist because and error has occurred during
            # its creation, the error has already been logged so we simply
            # ignore this exception. Or, maybe, a KeyboardInterrupt has been
            # raised just before the creation of the socket and the socket
            # still doesn't exist.
            pass
        
        except RuntimeError:
            # Probably this exception is raised by the join() method because
            # an error has occurred during socket starting. The error has
            # already been logged and we simply ignore this exception.
            pass
        
        except Exception as e:
            logger.error('unexpected error stopping control socket: {}', e, exc_info=True)
            
            # We set a new exit code only if this is the first error
            # otherwise we leave the original error exit code.
            if main_return_code == common.RET_CODE_OK:
                main_return_code = common.RET_CODE_SOCKET_STOP_ERR
        
        except KeyboardInterrupt:
            # We are already shutting down, no other operations required
            pass
        
        try:
            if heating.is_on():
                heating.switch_off()
                logger.info('heating switched OFF')
        
        except ScriptError as se:
            logger.warning('the script `{}` reported the following error '
                           'while shutting down the daemon: {}', se.script, se)
            
            # We set a new exit code only if this is the first error
            # otherwise we leave the original error exit code.
            if main_return_code == common.RET_CODE_OK:
                main_return_code = common.RET_CODE_SHUTDOWN_SWITCHOFF_ERR
        
        except HeatingError as he:
            logger.warning('error from heating while shutting down the '
                           'daemon: {}', he)
            
            # We set a new exit code only if this is the first error
            # otherwise we leave the original error exit code.
            if main_return_code == common.RET_CODE_OK:
                main_return_code = common.RET_CODE_SHUTDOWN_SWITCHOFF_ERR
        
        except Exception as e:
            logger.error('error in switching off the heating during '
                         'daemon shutdown: {}', e, exc_info=True)
            
            # We set a new exit code only if this is the first error
            # otherwise we leave the original error exit code.
            if main_return_code == common.RET_CODE_OK:
                main_return_code = common.RET_CODE_SHUTDOWN_OTHER_ERR
        
        except KeyboardInterrupt:
            # We are already shutting down, no other operations required
            pass
    
    logger.info('daemon stopped')


# main
if args.foreground or args.systemd:
    logger.debug('starting daemon in {}', (args.systemd and 'background by systemd' or 'foreground'))
    
    signal.signal(signal.SIGTERM, shutdown)
    signal.signal(signal.SIGHUP, reload_timetable)
    
    thermostat_cycle(timetable, heating, thermometer, lock, asyncio.get_event_loop())

else:
    logger.debug('starting daemon in background')
    
    daemon = DaemonContext()
    daemon.pidfile = pidfile.PIDLockFile(args.pid)
    daemon.files_preserve = []
    daemon.signal_map = {signal.SIGTERM: shutdown,
                         signal.SIGHUP: reload_timetable}
    
    if args.log:
        daemon.files_preserve.append(logfile.stream)
    
    if settings.thermometer['script'] == 'PiAnalogZero':
        try:
            daemon.files_preserve.append(MCP3008.spi.fileno())
        except AttributeError:
            # the thermometer is not using custom MCP3008 class
            pass
    
    try:
        with daemon:
            if settings.thermometer['script'] == 'PiAnalogZero':
                # The PiAnalogZeroThermometer must be created inside the
                # DaemonContext in case of background execution due to strange
                # behaviours of Thread and gpiozero.MCP3008 objects.
                thermometer = PiAnalogZeroThermometer(
                                    settings.thermometer['channels'],
                                    settings.thermometer['scale'],
                                    settings.thermometer['t_ref'],
                                    settings.thermometer['t_raw'])
            
            thermostat_cycle(timetable, heating, thermometer, lock, asyncio.get_event_loop())
    
    except lockfile.LockFailed:
        logger.critical('cannot create PID file {}', daemon.pidfile.path)
        main_return_code = common.RET_CODE_PID_FILE_ERROR
    
    except lockfile.AlreadyLocked:
        logger.critical('PID file {} is already locked', daemon.pidfile.path)
        main_return_code = common.RET_CODE_PID_FILE_ERROR
    
    except lockfile.LockError:
        logger.critical('unkown error writing PID file {}', daemon.pidfile.path)
        main_return_code = common.RET_CODE_PID_FILE_ERROR


# closing daemon
if main_return_code != common.RET_CODE_OK:
    logger.info('closing daemon with return code {}', main_return_code)

exit(main_return_code)

# vim: fileencoding=utf-8 tabstop=4 shiftwidth=4 expandtab
