#!/usr/bin/python3
# -*- coding: utf-8 -*-
"""Thermod daemon.

Copyright (C) 2017 Simone Rossetto <simros85@gmail.com>

This file is part of Thermod.

Thermod is free software: you can redistribute it and/or modify
it under the terms of the GNU General Public License as published by
the Free Software Foundation, either version 3 of the License, or
(at your option) any later version.

Thermod is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
GNU General Public License for more details.

You should have received a copy of the GNU General Public License
along with Thermod.  If not, see <http://www.gnu.org/licenses/>.
"""

import os
import sys
import logging
import argparse
import signal
import tempfile
import lockfile

from daemon import DaemonContext, pidfile
from logging.handlers import SysLogHandler, SMTPHandler
from jsonschema import ValidationError

from thermod import utils
from thermod.thermometer import ScriptThermometer, ThermometerError, PiAnalogZeroThermometer
from thermod.heating import ScriptHeating, HeatingError, PiPinsRelayHeating
from thermod.timetable import TimeTable
from thermod.socket import ControlThread
from thermod.utils import JsonValueError, ScriptError, LogStyleAdapter
from thermod.version import __version__ as PROGRAM_VERSION

__date__ = '2015-09-08'
__updated__ = '2017-02-25'

# TODO documentare return code
# TODO provare la generazione della documentazione con doxygen
# TODO rivedere documentazione e provare a generarla con con doxygen (doxypy oppure doxypypy)
# TODO creare manpage per questo file
# TODO capire come fare ad eseguire i test alla creazione del pacchetto deb
# TODO forse JsonValueError può essere tolto oppure il suo uso limitato, da pensarci
# TODO rivedere uso del grace-time

# TODO decidere se creare una classe Status da passare a Timetable per gestire
# lo stato corrent in maniera visuale su Raspberry Pi, oppure se creare un
# nuovo PiTimetable che deriva da Timetable e utilizza anche l'hardware del Pi.

script_path = os.path.dirname(os.path.realpath(__file__))
main_return_code = utils.RET_CODE_OK

# parsing input arguments
parser = argparse.ArgumentParser(description='Thermod: programmable thermostat daemon for smart-heating automation')
parser.add_argument('-v', '--version', action='version', version='%(prog)s {}'.format(PROGRAM_VERSION))
parser.add_argument('-C', '--config', action='store', default=None, help='read configuration from CONFIG file (full path)')
parser.add_argument('-D', '--debug', action='store_true', help='start the daemon in debug mode')
parser.add_argument('-F', '--foreground', action='store_true', help='start the daemon in foreground')
parser.add_argument('-L', '--log', action='store', default=None, help='write log messages to LOG file (full path)')
parser.add_argument('-P', '--pid', action='store', default='/run/thermod.pid', help='where to create PID file if required (full path)')
parser.add_argument('--systemd', action='store_true', help='use only if started by systemd')
args = parser.parse_args()

# setting up logging system
logger = LogStyleAdapter(logging.getLogger(utils.logger_base_name))
logger.setLevel(logging.INFO)

if args.debug:
    logger.setLevel(logging.DEBUG)

if args.foreground and not args.systemd:
    console = logging.StreamHandler(sys.stdout)
    console.setFormatter(logging.Formatter(fmt=utils.logger_fmt_msg,
                                           datefmt=utils.logger_fmt_time,
                                           style=utils.logger_fmt_style))
    logger.addHandler(console)
    logger.debug('executing in foreground, logging to console')
else:
    syslog = SysLogHandler(address='/dev/log', facility=SysLogHandler.LOG_DAEMON)
    syslog.setFormatter(logging.Formatter(fmt=utils.logger_fmt_msg_syslog,
                                          style=utils.logger_fmt_style))
    logger.addHandler(syslog)
    logger.debug('executing in background, logging to syslog (daemon)')

if args.log:
    logfile = None
    
    try:
        logfile = logging.FileHandler(args.log, mode='a')
    
    except PermissionError as pe:
        logger.warning('cannot write log to `{}`: {}', args.log, pe)
        
        try:
            (_fd, _path) = tempfile.mkstemp(prefix='tmp_thermod', suffix='.log', test=True)
            _fd.close()
            
            logger.info('the log will be written to temp file `{}`', _path)
            logfile = logging.FileHandler(_path, mode='w')
        
        except Exception as e:
            logger.error('cannot write logfile: {}', e)
            logger.info('the daemon will start without logfile')
    
    if logfile:
        logfile.setFormatter(logging.Formatter(fmt=utils.logger_fmt_msg,
                                               datefmt=utils.logger_fmt_datetime,
                                               style=utils.logger_fmt_style))
        logger.addHandler(logfile)


# reading configuration files
(cfg, main_return_code) = utils.read_config_files(args.config)

if main_return_code != utils.RET_CODE_OK:
    logger.info('closing daemon with return code {}', main_return_code)
    exit(main_return_code)


# parsing main settings
settings = utils.parse_main_settings(cfg)
debug = settings.debug or args.debug

if main_return_code != utils.RET_CODE_OK:
    logger.info('closing daemon with return code {}', main_return_code)
    exit(main_return_code)


# if executed in foreground we ignore the 'enabled' setting in config file
enabled = settings.enabled or args.foreground

# if the daemon is disabled we exit immediately
if not enabled:
    logger.info('daemon disabled in configuration file, exiting...')
    exit(utils.RET_CODE_DAEMON_DISABLED)


# if mail server is present in configuration file, a new SMTPHandler is created
if settings.email['server']:
    maillog = SMTPHandler(settings.email['server'],
                          settings.email['sender'],
                          settings.email['recipients'],
                          settings.email['subject'],
                          settings.email['credentials'])
    
    maillog.setFormatter(logging.Formatter(fmt=utils.logger_fmt_msg_maillog,
                                           datefmt=utils.logger_fmt_datetime,
                                           style=utils.logger_fmt_style))
    
    maillog.setLevel(logging.WARNING)
    logger.addHandler(maillog)


# setting again the debug level if requested in configuration file
if debug:
    logger.setLevel(logging.DEBUG)


# initializing base objects
try:
    logger.debug('creating base objects')
    
    if settings.heating['manager'] == 'scripts':
        heating = ScriptHeating(settings.heating['on'],
                                settings.heating['off'],
                                settings.heating['status'],
                                debug)
    
    elif settings.heating['manager'] == 'PiPinsRelay':
        heating = PiPinsRelayHeating(settings.heating['pins'],
                                     settings.heating['level'])
    
    # An `elif` can be added with additional specific heating classes
    # once they will be created.
    else:
        # The execution should not arrive here because the settings are
        # already checked inside utils.parse_main_settings() function.
        raise RuntimeError('invalid heating configuration')
    
    if settings.thermometer['script'][0] == '/':  # a full path starts with /
        thermometer = ScriptThermometer(settings.thermometer['script'], debug)
        
    elif settings.thermometer['script'] == 'PiAnalogZero':
        # The PiAnalogZeroThermometer uses Thread and gpiozero.MCP3008 objects
        # that have strange behaviours in case of python-daemon DaemonContext,
        # they must be created/started *inside* the DaemonContext, not outside.
        # So, in case of background launching with PiAnalogZeroThermometer, the
        # thermometer object is created inside DaemonContext (see at the end
        # of this file the same "if args.foreground or args.systemd").
        if args.foreground or args.systemd:
            thermometer = PiAnalogZeroThermometer(
                                settings.thermometer['channels'],
                                settings.thermometer['multiplier'],
                                settings.thermometer['shift'])
        else:
            # here thermod is launched in background
            thermometer = None
    
    # An `elif` can be added with additional specific thermometer classes
    # once they will be created.
    else:
        # The execution should not arrive here because the settings are
        # already checked inside utils.parse_main_settings() function.
        raise RuntimeError('invalid thermometer configuration')
    
    timetable = TimeTable(settings.tt_file)

except ScriptError as se:
    main_return_code = utils.RET_CODE_SCRIPT_INIT_ERR
    logger.critical('error accessing the script `{}`: {}', se.script, se)

except FileNotFoundError as fnfe:
    main_return_code = utils.RET_CODE_TT_NOT_FOUND
    logger.critical('cannot find timetable file `{}`', settings.tt_file)

except PermissionError as pe:
    main_return_code = utils.RET_CODE_TT_READ_ERR
    logger.critical('cannot read timetable file `{}`', settings.tt_file)

except OSError as oe:
    main_return_code = utils.RET_CODE_TT_OTHER_ERR
    logger.critical('error accessing timetable file `{}`: {}', settings.tt_file, oe)

except ValueError as ve:
    main_return_code = utils.RET_CODE_TT_INVALID_SYNTAX
    logger.critical('timetable file is not in JSON format or has syntax errors: {}', ve)

except ValidationError as jve:
    main_return_code = utils.RET_CODE_TT_INVALID_CONTENT
    logger.critical('invalid element {} in timetable file: {}', list(jve.path), jve.message)

except (HeatingError, ThermometerError) as pie:
    # TODO cambiare messaggio di log, non è detto che si sia su un Pi
    main_return_code = utils.RET_CODE_PI_INIT_ERR
    logger.critical('cannot access Raspberry Pi: {}', pie)

except RuntimeError as re:
    main_return_code = utils.RET_CODE_CFG_FILE_UNKNOWN_ERR
    logger.critical('error during creation of base objects: {}', re)

except Exception as e:
    main_return_code = utils.RET_CODE_INIT_ERR
    logger.critical('error during daemon initialization: {}', e, exc_info=True)

except KeyboardInterrupt:
    main_return_code = utils.RET_CODE_KEYB_INTERRUPT

except:
    main_return_code = utils.RET_CODE_INIT_ERR
    logger.critical('unknown error during daemon initialization, no more details', exc_info=True)

else:
    main_return_code = utils.RET_CODE_OK
    logger.debug('base objects created')
    
finally:
    if main_return_code != utils.RET_CODE_OK:
        logger.info('closing daemon with return code {}', main_return_code)
        exit(main_return_code)


def shutdown(signum=None, frame=None, exitcode=utils.RET_CODE_OK):
    global enabled, main_return_code
    
    logger.info('shutdown requested')
    with timetable.lock:
        enabled = False
        timetable.lock.notify_all()
    
    # setting the global return code
    main_return_code = exitcode


def reload_timetable(signum=None, frame=None):
    logger.info('timetable reload requested')
    with timetable.lock:
        try:
            timetable.reload()
            timetable.lock.notify_all()
        
        except OSError as oe:
            logger.warning('cannot reload timetable file `{}`, old settings '
                           'remain unchanged: {}', timetable.filepath, oe)
        
        except ValidationError as jsve:
            logger.warning('cannot reload settings, timetable file contains '
                           'invalid data in element {}: {}', list(jsve.path),
                           jsve.message)
        
        except ValueError as ve:
            logger.warning('cannot reload settings, timetable file contains '
                           'invalid data: {}', ve)
        
        except Exception as e:
            logger.warning('error while reloading timetable, old settings '
                           'remain unchanged: {}', e)


def thermostat_cycle(timetable, heating, thermometer):
    """The main cycle of temperature checking.
    
    Periodically checks the temperature and switch on/off the heating
    accordingly.
    """
    
    global main_return_code
    logger.info('daemon started ({})', PROGRAM_VERSION)
    
    try:
        # starting control socket
        socket = ControlThread(timetable, heating, thermometer, settings.host, settings.port)
        socket.start()
    
    except OSError as oe:
        # probably the socket address is already in use
        logger.critical('cannot start control socket: {}', oe)
        main_return_code = utils.RET_CODE_SOCKET_PORT_ERR
    
    except Exception as e:
        logger.critical('cannot start control socket: {}', e, exc_info=True)
        main_return_code = utils.RET_CODE_SOCKET_START_ERR

    except KeyboardInterrupt:
        main_return_code = utils.RET_CODE_KEYB_INTERRUPT
    
    except:
        logger.critical('unkown error starting control socket', exc_info=True)
        main_return_code = utils.RET_CODE_SOCKET_START_ERR
    
    else:
        try:
            logger.info('the heating is currently {}', (heating.is_on() and 'ON' or 'OFF'))
            
        except Exception as e:
            # We report the error as a severe error but we do nothing because
            # it can be a transient error, if it isn't transient, the error
            # will appears again in the hereafter "while" cycle and it will
            # be managed there.
            logger.error('cannot query the heating to retrieve current status: {}', e)
            
        except KeyboardInterrupt:
            shutdown(exitcode=utils.RET_CODE_KEYB_INTERRUPT)
            
        except:
            logger.critical('unknown error during first query to the heating', exc_info=True)
            shutdown(exitcode=utils.RET_CODE_RUN_HEATING_ERR)
        
        # The following variable is needed to print info messages only
        # when no timeout has occurred, that means that someone has changed
        # some settings.
        cycle_timeout = False
        
        # the real cycle of temperature checking
        while enabled:
            try:
                with timetable.lock:
                    try:
                        should_be_on = timetable.should_the_heating_be_on(
                                            thermometer.temperature,
                                            heating.status,
                                            heating.switch_off_time)
                        
                        _msg = ('status: {!r}, '
                                'current: {:.1f}, '
                                'target: {:.1f}').format(
                                            should_be_on.status,
                                            should_be_on.current_temperature,
                                            should_be_on.target_temperature)
                        
                        if should_be_on:
                            if not heating.is_on():
                                heating.switch_on()
                                logger.info('heating switched ON ({})', _msg)
                            elif not cycle_timeout:
                                logger.info('heating already ON ({})', _msg)
                            else:
                                logger.debug('heating already ON ({})', _msg)
                        else:
                            if heating.is_on():
                                heating.switch_off()
                                logger.info('heating switched OFF ({})', _msg)
                            elif not cycle_timeout:
                                logger.info('heating already OFF ({})', _msg)
                            else:
                                logger.debug('heating already OFF ({})', _msg)
                    
                    except ValidationError as ve:
                        # The internal settings must be valid otherwise an error
                        # should have been already catched in other sections of
                        # the daemon, even if new settings are set from
                        # socket connection. So we print a critical error and
                        # we close the daemon.
                        logger.critical('invalid element {} in timetable file: {}', list(ve.path), ve)
                        shutdown(exitcode=utils.RET_CODE_RUN_INVALID_STATE)
                    
                    except JsonValueError as jve:
                        # A strange value has been set somewhere and the daemon
                        # didn't catch the appropriate exception. We print a
                        # critical message and we close the daemon.
                        logger.critical(jve)
                        shutdown(exitcode=utils.RET_CODE_RUN_INVALID_VALUE)
                    
                    except ScriptError as se:
                        # One of the external scripts reported an error, we
                        # print it as a severe error but we leave the daemon
                        # running even if probably it is not fully functional.
                        logger.error('the script `{}` reported the following '
                                     'error: {}', se.script, se)
                    
                    except ThermometerError as te:
                        logger.error('error from thermometer: {}', te)
                        logger.debug(te.suberror)
                    
                    except HeatingError as he:
                        logger.error('error from heating: {}', he)
                        logger.debug(he.suberror)
                    
                    # A shutdown may have been requested before reaching
                    # this point and in such situation we don't have to
                    # wait for a notify, simply go on and exit the cycle.
                    if enabled:
                        # We suspend the process and wait to recheck the temperature.
                        # The 'wait' method returns False on timeout, thus we
                        # negate it to have cycle_timeout equal True when a
                        # timeout has occurred.
                        cycle_timeout = not timetable.lock.wait(settings.interval)
            
            
            except Exception as e:
                # An unknown error occurred somewhere
                logger.critical('unknown error occurred: {}', e, exc_info=True)
                shutdown(exitcode=utils.RET_CODE_RUN_OTHER_ERR)
            
            except KeyboardInterrupt:
                shutdown(exitcode=utils.RET_CODE_KEYB_INTERRUPT)
            
            except:
                logger.critical('unknown error during normal operation', exc_info=True)
                shutdown(exitcode=utils.RET_CODE_RUN_OTHER_ERR)
    
    finally:    
        logger.debug('stopping daemon')
        
        try:
            with timetable.lock:
                socket.stop()
                socket.join(10)
        
        except NameError:
            # The socket doesn't exist because and error has occurred during
            # its creation, the error has already been logged so we simply
            # ignore this exception. Or, maybe, a KeyboardInterrupt has been
            # raised just before the creation of the socket and the socket
            # still doesn't exist.
            pass
        
        except RuntimeError:
            # Probably this exception is raised by the join() method because
            # an error has occurred during socket starting. The error has
            # already been logged and we simply ignore this exception.
            pass
        
        except Exception as e:
            logger.error('unexpected error stopping control socket: {}', e, exc_info=True)
            
            # We set a new exit code only if this is the first error
            # otherwise we leave the original error exit code.
            if main_return_code == utils.RET_CODE_OK:
                main_return_code = utils.RET_CODE_SOCKET_STOP_ERR
        
        except KeyboardInterrupt:
            # We are already shutting down, no other operations required
            pass
        
        except:
            logger.error('unknown error stopping control socket', exc_info=True)
            
            # We set a new exit code only if this is the first error
            # otherwise we leave the original error exit code.
            if main_return_code == utils.RET_CODE_OK:
                main_return_code = utils.RET_CODE_SOCKET_STOP_ERR
        
        try:
            if heating.is_on():
                heating.switch_off()
                logger.info('heating switched OFF')
        
        except ScriptError as se:
            logger.warning('the script `{}` reported the following error '
                           'while shutting down the daemon: {}', se.script, se)
            
            # We set a new exit code only if this is the first error
            # otherwise we leave the original error exit code.
            if main_return_code == utils.RET_CODE_OK:
                main_return_code = utils.RET_CODE_SHUTDOWN_SWITCHOFF_ERR
        
        except HeatingError as he:
            logger.warning('error from heating while shutting down the '
                           'daemon: {}', he)
            
            # We set a new exit code only if this is the first error
            # otherwise we leave the original error exit code.
            if main_return_code == utils.RET_CODE_OK:
                main_return_code = utils.RET_CODE_SHUTDOWN_SWITCHOFF_ERR
        
        except Exception as e:
            logger.error('error in switching off the heating during '
                         'daemon shutdown: {}', e, exc_info=True)
            
            # We set a new exit code only if this is the first error
            # otherwise we leave the original error exit code.
            if main_return_code == utils.RET_CODE_OK:
                main_return_code = utils.RET_CODE_SHUTDOWN_OTHER_ERR
        
        except KeyboardInterrupt:
            # We are already shutting down, no other operations required
            pass
        
        except:
            logger.error('unknown error in switching off the heating during '
                         'daemon shutdown', exc_info=True)
            
            # We set a new exit code only if this is the first error
            # otherwise we leave the original error exit code.
            if main_return_code == utils.RET_CODE_OK:
                main_return_code = utils.RET_CODE_SHUTDOWN_OTHER_ERR
    
    logger.info('daemon stopped')


# main
if args.foreground or args.systemd:
    logger.debug('starting daemon in {}', (args.systemd and 'background by systemd' or 'foreground'))
    
    signal.signal(signal.SIGTERM, shutdown)
    signal.signal(signal.SIGHUP, reload_timetable)
    
    thermostat_cycle(timetable, heating, thermometer)

else:
    logger.debug('starting daemon in background')
    
    daemon = DaemonContext()
    daemon.pidfile = pidfile.PIDLockFile(args.pid)
    daemon.signal_map = {signal.SIGTERM: shutdown,
                         signal.SIGHUP: reload_timetable}
    
    if args.log:
        daemon.files_preserve = [logfile.stream]
    
    try:
        with daemon:
            if settings.thermometer['script'] == 'PiAnalogZero':
                # The PiAnalogZeroThermometer must be created inside the
                # DaemonContext in case of background execution due to strange
                # behaviours of Thread and gpiozero.MCP3008 objects.
                thermometer = PiAnalogZeroThermometer(
                                    settings.thermometer['channels'],
                                    settings.thermometer['multiplier'],
                                    settings.thermometer['shift'])
            
            thermostat_cycle(timetable, heating, thermometer)
    
    except lockfile.LockFailed:
        logger.critical('cannot create PID file {}', daemon.pidfile.path)
        main_return_code = utils.RET_CODE_PID_FILE_ERROR
    
    except lockfile.AlreadyLocked:
        logger.critical('PID file {} is already locked', daemon.pidfile.path)
        main_return_code = utils.RET_CODE_PID_FILE_ERROR
    
    except lockfile.LockError:
        logger.critical('unkown error writing PID file {}', daemon.pidfile.path)
        main_return_code = utils.RET_CODE_PID_FILE_ERROR


# closing daemon
if main_return_code != utils.RET_CODE_OK:
    logger.info('closing daemon with return code {}', main_return_code)

exit(main_return_code)

# vim: fileencoding=utf-8 tabstop=4 shiftwidth=4 expandtab
