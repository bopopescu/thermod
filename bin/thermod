#!/usr/bin/python3
# -*- coding: utf-8 -*-
"""Thermod daemon.

Copyright (C) 2017 Simone Rossetto <simros85@gmail.com>

This file is part of Thermod.

Thermod is free software: you can redistribute it and/or modify
it under the terms of the GNU General Public License as published by
the Free Software Foundation, either version 3 of the License, or
(at your option) any later version.

Thermod is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
GNU General Public License for more details.

You should have received a copy of the GNU General Public License
along with Thermod.  If not, see <http://www.gnu.org/licenses/>.
"""

import os
import sys
import logging
import argparse
import signal
import tempfile
import asyncio
import time

from logging.handlers import SysLogHandler, SMTPHandler
from jsonschema import ValidationError
from async_timeout import timeout

from thermod import common, config
from thermod.common import ScriptError, LogStyleAdapter, ThermodStatus
from thermod.thermometer import ScriptThermometer, ThermometerError, PiAnalogZeroThermometer
from thermod.heating import ScriptHeating, HeatingError, PiPinsRelayHeating
from thermod.timetable import TimeTable, JsonValueError
from thermod.socket import ControlSocket
from thermod.version import __version__ as PROGRAM_VERSION

__date__ = '2015-09-08'
__updated__ = '2017-12-17'

# TODO documentare return code
# TODO rivedere documentazione e provare a generarla con con doxygen (doxypy oppure doxypypy)
# TODO creare manpage per questo file
# TODO capire come fare ad eseguire i test alla creazione del pacchetto deb
# TODO fare client testuale
# TODO inserire controllo su variazioni repentine di temperatura

script_path = os.path.dirname(os.path.realpath(__file__))
main_return_code = common.RET_CODE_OK

# parsing input arguments
parser = argparse.ArgumentParser(description='Thermod: programmable thermostat daemon for smart-heating automation')
parser.add_argument('-v', '--version', action='version', version='%(prog)s {}'.format(PROGRAM_VERSION))
parser.add_argument('-C', '--config', action='store', default=None, help='read configuration from CONFIG file (full path)')
parser.add_argument('-D', '--debug', action='store_true', help='start the daemon in debug mode')
parser.add_argument('-F', '--foreground', action='store_true', help='start the daemon in foreground (log to console and start even if disabled in config file)')
parser.add_argument('-L', '--log', action='store', default=None, help='write log messages also to LOG file (full path)')
args = parser.parse_args()

# setting up logging system
logger = LogStyleAdapter(logging.getLogger(common.LOGGER_BASE_NAME))
logger.setLevel(logging.INFO)

if args.debug:
    logger.setLevel(logging.DEBUG)

if args.foreground:
    console = logging.StreamHandler(sys.stdout)
    console.setFormatter(logging.Formatter(fmt=common.LOGGER_FMT_MSG,
                                           datefmt=common.LOGGER_FMT_TIME,
                                           style=common.LOGGER_FMT_STYLE))
    logger.addHandler(console)
    logger.debug('logging to console')
else:
    syslog = SysLogHandler(address='/dev/log', facility=SysLogHandler.LOG_DAEMON)
    syslog.setFormatter(logging.Formatter(fmt=common.LOGGER_FMT_MSG_SYSLOG,
                                          style=common.LOGGER_FMT_STYLE))
    logger.addHandler(syslog)
    logger.debug('logging to syslog (daemon section)')

if args.log:
    logfile = None
    
    try:
        logfile = logging.FileHandler(args.log, mode='a')
    
    except PermissionError as pe:
        logger.warning('cannot write log to `{}`: {}', args.log, pe)
        
        try:
            (_fd, _path) = tempfile.mkstemp(prefix='tmp_thermod', suffix='.log', test=True)
            _fd.close()
            
            logger.info('the log will be written to temp file `{}`', _path)
            logfile = logging.FileHandler(_path, mode='w')
        
        except Exception as e:
            logger.error('cannot write logfile: {}', e)
            logger.info('the daemon will start without logfile')
    
    if logfile:
        logfile.setFormatter(logging.Formatter(fmt=common.LOGGER_FMT_MSG,
                                               datefmt=common.LOGGER_FMT_DATETIME,
                                               style=common.LOGGER_FMT_STYLE))
        logger.addHandler(logfile)


# reading configuration files
(cfg, main_return_code) = config.read_config_file(args.config)

if main_return_code != common.RET_CODE_OK:
    logger.info('closing daemon with return code {}', main_return_code)
    exit(main_return_code)


# parsing main settings
settings = config.parse_main_settings(cfg)
debug = settings.debug or args.debug

if main_return_code != common.RET_CODE_OK:
    logger.info('closing daemon with return code {}', main_return_code)
    exit(main_return_code)


# if executed in foreground we ignore the 'enabled' setting in config file
enabled = settings.enabled or args.foreground

# if the daemon is disabled we exit immediately
if not enabled:
    logger.info('daemon disabled in configuration file, exiting...')
    exit(common.RET_CODE_DAEMON_DISABLED)


# if mail server is present in configuration file, a new SMTPHandler is created
if settings.email['server']:
    maillog = SMTPHandler(settings.email['server'],
                          settings.email['sender'],
                          settings.email['recipients'],
                          settings.email['subject'],
                          settings.email['credentials'])
    
    maillog.setFormatter(logging.Formatter(fmt=common.LOGGER_FMT_MSG_MAILLOG,
                                           datefmt=common.LOGGER_FMT_DATETIME,
                                           style=common.LOGGER_FMT_STYLE))
    
    maillog.setLevel(logging.WARNING)
    logger.addHandler(maillog)


# setting again the debug level if requested in configuration file
if debug:
    logger.setLevel(logging.DEBUG)


# initializing base objects
try:
    logger.debug('creating base objects')
    
    # the main event loop
    main_loop = asyncio.get_event_loop()
    
    # the main lock
    masterlock = asyncio.Condition(loop=main_loop)
    
    # the timetable
    timetable = TimeTable(settings.tt_file, settings.mode)
    
    # the heating
    if settings.heating['manager'] == 'scripts':
        heating = ScriptHeating(settings.heating['on'],
                                settings.heating['off'],
                                settings.heating['status'],
                                debug)
    
    elif settings.heating['manager'] == 'PiPinsRelay':
        heating = PiPinsRelayHeating(settings.heating['pins'],
                                     settings.heating['level'])
    
    # An `elif` can be added with additional specific heating classes
    # once they will be created.
    else:
        # The execution should not arrive here because the settings are
        # already checked inside common.parse_main_settings() function.
        raise RuntimeError('invalid heating configuration')
    
    # the thermometer
    if settings.thermometer['script'][0] == '/':  # a full path starts with /
        thermometer = ScriptThermometer(settings.thermometer['script'],
                                        debug,
                                        settings.thermometer['scale'],
                                        settings.thermometer['t_ref'],
                                        settings.thermometer['t_raw'])
        
    elif settings.thermometer['script'] == 'PiAnalogZero':
        thermometer = PiAnalogZeroThermometer(settings.thermometer['channels'],
                                              settings.thermometer['scale'],
                                              settings.thermometer['t_ref'],
                                              settings.thermometer['t_raw'],
                                              settings.thermometer['stddev'],
                                              settings.thermometer['realint'],
                                              settings.thermometer['avgtime'],
                                              loop=main_loop)
    
    # An `elif` can be added with additional specific thermometer classes
    # once they will be created.
    else:
        # The execution should not arrive here because the settings are
        # already checked inside common.parse_main_settings() function.
        raise RuntimeError('invalid thermometer configuration')
    
    # the control socket
    # TODO controllare gli errori possibili alla creazione del socket asyncrono
    socket = ControlSocket(timetable, heating, thermometer,
                           settings.host, settings.port,
                           masterlock, main_loop)

except ScriptError as se:
    main_return_code = common.RET_CODE_SCRIPT_INIT_ERR
    logger.critical('error accessing the script `{}`: {}', se.script, se)

except FileNotFoundError as fnfe:
    main_return_code = common.RET_CODE_TT_NOT_FOUND
    logger.critical('cannot find timetable file `{}`', settings.tt_file)

except PermissionError as pe:
    main_return_code = common.RET_CODE_TT_READ_ERR
    logger.critical('cannot read timetable file `{}`', settings.tt_file)

except OSError as oe:
    main_return_code = common.RET_CODE_OS_INIT_ERR
    logger.critical('error during creation of base objects: {}', oe)

except ValueError as ve:
    main_return_code = common.RET_CODE_TT_INVALID_SYNTAX
    logger.critical('timetable file is not in JSON format or has syntax errors: {}', ve)

except ValidationError as jsve:
    main_return_code = common.RET_CODE_TT_INVALID_CONTENT
    logger.critical('invalid element {} in timetable file: {}', list(jsve.path), jsve.message)

except HeatingError as he:
    main_return_code = common.RET_CODE_HW_INIT_ERR
    logger.critical('cannot initialize heating: {}', he)

except ThermometerError as te:
    main_return_code = common.RET_CODE_HW_INIT_ERR
    logger.critical('cannot initialize thermometer: {}', he)

except RuntimeError as re:
    main_return_code = common.RET_CODE_CFG_FILE_UNKNOWN_ERR
    logger.critical('error during creation of base objects: {}', re)

except Exception as e:
    main_return_code = common.RET_CODE_INIT_ERR
    logger.critical('error during daemon initialization: {}', e, exc_info=True)

except KeyboardInterrupt:
    main_return_code = common.RET_CODE_KEYB_INTERRUPT

else:
    main_return_code = common.RET_CODE_OK
    logger.debug('base objects created')
    
finally:
    if main_return_code != common.RET_CODE_OK:
        logger.info('closing daemon with return code {}', main_return_code)
        exit(main_return_code)


def shutdown(signum=None, frame=None, exitcode=common.RET_CODE_OK):
    global enabled, main_return_code, masterlock

    logger.info('shutdown requested')
    with masterlock:
        enabled = False
        masterlock.notify_all()

    # setting the global return code
    main_return_code = exitcode


def reload_timetable(signum=None, frame=None):
    global masterlock
    
    logger.info('timetable reload requested')
    with masterlock:
        try:
            timetable.reload()
            masterlock.notify_all()
        
        except OSError as oe:
            logger.warning('cannot reload timetable file `{}`, old settings '
                           'remain unchanged: {}', timetable.filepath, oe)
        
        except ValidationError as jsve:
            logger.warning('cannot reload settings, timetable file contains '
                           'invalid data in element {}: {}', list(jsve.path),
                           jsve.message)
        
        except ValueError as ve:
            logger.warning('cannot reload settings, timetable file contains '
                           'invalid data: {}', ve)
        
        except Exception as e:
            logger.warning('error while reloading timetable, old settings '
                           'remain unchanged: {}', e)


async def thermostat_cycle(timetable, heating, thermometer, lock, loop):
    """The main cycle of temperature checking.
    
    Periodically checks the temperature and switch on/off the heating
    accordingly.
    
    If a known error is catched somewhere, a message is printed to syslog and
    the daemon is leaved running even if a manual operation of the user is
    required to fix the contidion. In case of unknown error, a critical message
    is printed and the daemon is closed.
    """
    
    global main_return_code
    logger.info('daemon started ({})', PROGRAM_VERSION)
    if True:  # TODO togliere questo if, serve solo per formattare correttamente
        try:
            logger.info('the heating is currently {}', (heating.is_on() and 'ON' or 'OFF'))
            
        except Exception as e:
            # We report the error as a severe error but we do nothing because
            # it can be a transient error, if it isn't transient, the error
            # will appears again in the hereafter "while" cycle and it will
            # be managed there.
            logger.error('cannot query the heating to retrieve current status: {}', e)
            
        except KeyboardInterrupt:
            shutdown(exitcode=common.RET_CODE_KEYB_INTERRUPT)
        
        # The following variable is needed to print info messages only
        # when no timeout has occurred, that means that someone has changed
        # some settings.
        cycle_timeout = False
        
        # the real cycle of temperature checking
        while enabled:
            try:
                with lock:
                    try:
                        should_be_on = timetable.should_the_heating_be_on(
                                            thermometer.temperature,
                                            heating.status)
                        
                        _msg = ('status: {!r}, '
                                'current: {:.1f}, '
                                'target: {:.1f}').format(
                                    should_be_on.status.status,
                                    should_be_on.status.current_temperature,
                                    float(should_be_on.status.target_temperature or 'NaN'))
                        
                        if should_be_on == should_be_on.status.heating_status:
                            # The heating is already as it should be, so an
                            # info message is printed only if some settings
                            # have been changed from outside (the timeout has
                            # not occurred).
                            log = (logger.info if not cycle_timeout else logger.debug)
                            log('heating already {} ({})',
                                ('ON' if should_be_on.status.heating_status else 'OFF'),
                                _msg)
                        
                        else:  # the heating must be switched
                            if should_be_on:
                                heating.switch_on()
                            else:
                                heating.switch_off()
                            
                            logger.info('heating switched {} ({})',
                                        ('ON' if should_be_on else 'OFF'),
                                        _msg)
                    
                    except ValidationError as jsve:
                        # The internal settings must be valid otherwise an error
                        # should have already been catched in other sections of
                        # the program, even if new settings are set from
                        # socket connection. We print a critical message but
                        # we leave the daemon running. Manual intervention of
                        # the user is required to fix this condition.
                        newstatus = ThermodStatus(time.time(), error='Invalid element in timetable file')
                        logger.critical('invalid element {} in timetable file: {}', list(jsve.path), jsve)
                        #shutdown(exitcode=common.RET_CODE_RUN_INVALID_STATE)
                    
                    except JsonValueError as jve:
                        # A strange value has been set somewhere and the daemon
                        # didn't catch the appropriate exception. We print a
                        # critical message but we leave the daemon running.
                        # Manual intervention of the user is required to fix
                        # this condition.
                        newstatus = ThermodStatus(time.time(), error='Invalid value in running daemon')
                        logger.critical(jve)
                        #shutdown(exitcode=common.RET_CODE_RUN_INVALID_VALUE)
                    
                    except ScriptError as se:
                        # One of the external scripts reported an error, we
                        # print it as a severe error but we leave the daemon
                        # running even if probably it is not fully functional.
                        newstatus = ThermodStatus(time.time(), error='Error in script {}'.format(se.script))
                        logger.error('the script `{}` reported the following '
                                     'error: {}', se.script, se)
                    
                    except ThermometerError as te:
                        newstatus = ThermodStatus(time.time(), error='Error from thermometer')
                        logger.error('error from thermometer: {}', te)
                        logger.debug(te.suberror)
                    
                    except HeatingError as he:
                        newstatus = ThermodStatus(time.time(), error='Error from heating')
                        logger.error('error from heating: {}', he)
                        logger.debug(he.suberror)
                    
                    except Exception:
                        # There is an unknown error. We create an error-status
                        # for monitors and we re-raise the exception.
                        newstatus = ThermodStatus(time.time(), error='Unknown Error')
                        raise
                    
                    except KeyboardInterrupt:
                        newstatus = ThermodStatus(time.time(), error='Shutting down Thermod')
                        raise
                    
                    else:
                        newstatus = should_be_on.status._replace(heating_status=heating.status)
                    
                    finally:  # we update all connected monitors
                        loop.create_task(socket.update_monitors(newstatus))
                    
                    # A shutdown may have been requested before reaching
                    # this point and in such situation we don't have to
                    # wait for a notify, simply go on and exit the cycle.
                    if enabled:
                        # We suspend the process and wait to check again the
                        # temperature. The wait is wrapped in a timeout to force
                        # a check at least any `settings.interval` seconds.
                        try:
                            async with timeout(settings.interval, loop):
                                await lock.wait()
                        
                        except asyncio.TimeoutError:
                            cycle_timeout = True
                        
                        else:
                            cycle_timeout = False
            
            
            except Exception as e:
                # An unknown error occurred somewhere, a critical message is
                # printed and the daemon will be closed.
                logger.critical('unknown error occurred: {}', e, exc_info=True)
                shutdown(exitcode=common.RET_CODE_RUN_OTHER_ERR)
            
            except KeyboardInterrupt:
                shutdown(exitcode=common.RET_CODE_KEYB_INTERRUPT)
    
    logger.info('daemon stopped')


# main
logger.debug('starting daemon')

signal.signal(signal.SIGTERM, shutdown)
signal.signal(signal.SIGHUP, reload_timetable)

#main_task = main_loop.create_task(thermostat_cycle(timetable, heating, thermometer, masterlock, main_loop))

# start control socket
try:
    with masterlock:
        socket.start()

except OSError as oe:
    # probably the socket address is already in use
    logger.critical('cannot start control socket: {}', oe)
    main_return_code = common.RET_CODE_SOCKET_PORT_ERR

except Exception as e:
    logger.critical('cannot start control socket: {}', e, exc_info=True)
    main_return_code = common.RET_CODE_SOCKET_START_ERR

except KeyboardInterrupt:
    main_return_code = common.RET_CODE_KEYB_INTERRUPT

else:
    main_return_code = common.RET_CODE_OK

finally:
    if main_return_code != common.RET_CODE_OK:
        logger.info('closing daemon with return code {}', main_return_code)
        exit(main_return_code)

# run the loop
try:
    logger.debug('starting main event loop')
    main_loop.run_until_complete(thermostat_cycle(timetable, heating, thermometer, masterlock, main_loop))

# TODO verificare quali altre eccezioni potrebbero verificarsi
finally:
    logger.debug('finalizing daemon shutdown')
    
    # stop the socket
    try:
        with masterlock:
            socket.stop()
    
    except Exception as e:
        logger.error('unexpected error stopping control socket: {}', e, exc_info=True)
        
        # We set a new exit code only if this is the first error
        # otherwise we leave the original error exit code.
        if main_return_code == common.RET_CODE_OK:
            main_return_code = common.RET_CODE_SOCKET_STOP_ERR
    
    except KeyboardInterrupt:
        # We are already shutting down, no other operations required
        pass
    
    # switch off the heating
    try:
        if heating.is_on():
            heating.switch_off()
            logger.info('heating switched OFF')
    
    except ScriptError as se:
        logger.warning('the script `{}` reported the following error '
                       'while shutting down the daemon: {}', se.script, se)
        
        # We set a new exit code only if this is the first error
        # otherwise we leave the original error exit code.
        if main_return_code == common.RET_CODE_OK:
            main_return_code = common.RET_CODE_SHUTDOWN_SWITCHOFF_ERR
    
    except HeatingError as he:
        logger.warning('error from heating while shutting down the '
                       'daemon: {}', he)
        
        # We set a new exit code only if this is the first error
        # otherwise we leave the original error exit code.
        if main_return_code == common.RET_CODE_OK:
            main_return_code = common.RET_CODE_SHUTDOWN_SWITCHOFF_ERR
    
    except Exception as e:
        logger.error('error switching off the heating during '
                     'daemon shutdown: {}', e, exc_info=True)
        
        # We set a new exit code only if this is the first error
        # otherwise we leave the original error exit code.
        if main_return_code == common.RET_CODE_OK:
            main_return_code = common.RET_CODE_SHUTDOWN_OTHER_ERR
    
    except KeyboardInterrupt:
        # We are already shutting down, no other operations required
        pass
    
    # close the main loop
    logger.debug('closing main event loop')
    main_loop.close()


# closing daemon
if main_return_code != common.RET_CODE_OK:
    logger.info('closing daemon with return code {}', main_return_code)

exit(main_return_code)

# vim: fileencoding=utf-8 tabstop=4 shiftwidth=4 expandtab
